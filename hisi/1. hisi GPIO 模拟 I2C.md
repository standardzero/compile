[TOC]

# 1. I2C 简介

I2C总线的主控器，要对连在总线上的某个从器件进行读/写操作时，会先在总线上发出该从器件的地址，各个从器件把自己的地址与这个地址比较。每个I2C器件在出厂时都会固化自己的I2C地址的，也有通过硬件引脚选择I2C地址的；而且I2C器件内部有MCU，可以识别总线上的信号并根据信号作出相应的处理；在接收到总线上的地址位后，会与自身的地址比较，一旦相同，则发出应答信号。

I2C地址，8位地址，减去1位广播地址（0：写；1：读），是7位地址，2^7=128，但是地址0x00不用，那就是127个地址，所以理论上可以挂127个从器件。

**注**：I2C总线正常工作输出端必须接上拉电阻。

# 2. I2C 时序图
![title](https://raw.githubusercontent.com/standardzero/picture2/master/gitnote/2019/05/28/logic-1559023932257.png)

# 3. hisi GPIO 模拟 I2C

## 3.1 封装 GPIO

```
typedef struct _GpioMuxerPin
{
	uint8_t muxer_pin_grp; //  GPIO 组 
	uint8_t muxer_num;     //  GPIO 组里的 GPIO
	uint8_t dir; //0-in , 1- out
	uint8_t val;
}GpioMuxerPin;
```

## 3.2 封装 I2C

```
typedef struct _I2CInfo
{
	uint8_t index;
	GpioMuxerPin stSCL;
	GpioMuxerPin stSDA;
}I2CInfo;

//定义 8 组 I2C
static I2CInfo s_arrI2CInfo[] = {
		{0, {9, 0, 1, 1}, {9, 1, 1, 1}},
		{1, {9, 2, 1, 1}, {9, 3, 1, 1}},
		{2, {9, 4, 1, 1}, {9, 5, 1, 1}},
		{3, {10, 3, 1, 1}, {10, 4, 1, 1}},
		{4, {10, 5, 1, 1}, {10, 6, 1, 1}},
		{5, {10, 7, 1, 1}, {0, 0, 1, 1}},
		{6, {0, 1, 1, 1}, {0, 2, 1, 1}},
		{7, {0, 3, 1, 1}, {0, 4, 1, 1}}
};
```

## 3.3 获取同组GPIO的方向

```
static U32 GetRegDir(int gpio_grp)
{
	int i = 0;
	U32 reg_val = 0;
	
	switch(gpio_grp)
	{
		case 0:
		{
			reg_val |= (s_arrI2CInfo[5].stSDA.dir);
			reg_val |= (s_arrI2CInfo[6].stSCL.dir << 1);
			reg_val |= (s_arrI2CInfo[6].stSDA.dir << 2);
			reg_val |= (s_arrI2CInfo[7].stSCL.dir << 3);
			reg_val |= (s_arrI2CInfo[7].stSDA.dir << 4);
			break;
		}
		case 9:
		{
			reg_val |= (s_arrI2CInfo[0].stSCL.dir);
			reg_val |= (s_arrI2CInfo[0].stSDA.dir << 1);
			reg_val |= (s_arrI2CInfo[1].stSCL.dir << 2);
			reg_val |= (s_arrI2CInfo[1].stSDA.dir << 3);
			reg_val |= (s_arrI2CInfo[2].stSCL.dir << 4);
			reg_val |= (s_arrI2CInfo[2].stSDA.dir << 5);
			break;
		}
		case 10:
		{
			reg_val |= (s_arrI2CInfo[3].stSCL.dir << 3);
			reg_val |= (s_arrI2CInfo[3].stSDA.dir << 4);
			reg_val |= (s_arrI2CInfo[4].stSCL.dir << 5);
			reg_val |= (s_arrI2CInfo[4].stSDA.dir << 6);
			reg_val |= (s_arrI2CInfo[5].stSCL.dir << 7);
			break;
		}
		default:
		{
			break;
		}
	}

	return reg_val;
}
```

hisi 操作GPIO的方向时，一组只提供了一个寄存器，每个bit都能够单独操作。 
为了避免多次回读寄存器，可以设计一个结构体存储GPIO的状态。

## 3.4 模拟I2C的时序

**i2c_gpio.c**

```
/*******************************************************************************
 * i2c_gpio.c
 *
 * History:
 *   2017-06-29 - [lei.huang] created file
 *
 * Details: 
 *   I2C implented with gpios.
 *
 * Copyright(c), 2017 WELLAV Technology Co.,Ltd.
 * All rights reserved.
 *
 * All rights reserved. No Part of this file may be reproduced, stored
 * in a retrieval system, or transmitted, in any form, or by any means,
 * electronic, mechanical, photocopying, recording, or otherwise,
 * without the prior consent of WELLAV Tech.
*******************************************************************************/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdbool.h>
#include <pthread.h>

#include "appGlobal.h"
#include "i2c_gpio.h"
#include "wv_gpio.h"

#define SEL_SCL                             1
#define SEL_SDA                             0

//#define IIC_FAST_MODE
#ifdef IIC_FAST_MODE
#define TIME_SETUP_START                    0
#define TIME_HOLD_START                     0
#define TIME_DEALY_START                    0
#define TIME_SETUP_DIN                      0
#define TIME_HOLD_DIN                       0
#define TIME_SETUP_DOUT                     0
#define TIME_HOLD_DOUT                      0
#define TIME_SETUP_STOP                     0
#define TIME_SCL_HIGH                       0
#define TIME_SCL_LOW0                       0
#define TIME_SCL_LOW1                       0
#else
#define TIME_SETUP_START                    2
#define TIME_HOLD_START                     2
#define TIME_DEALY_START                    3
#define TIME_SETUP_DIN                      2
#define TIME_HOLD_DIN                       3
#define TIME_SETUP_DOUT                     3
#define TIME_HOLD_DOUT                      3
#define TIME_SETUP_STOP                     2
#define TIME_SCL_HIGH                       5
#define TIME_SCL_LOW0                       3
#define TIME_SCL_LOW1                       2
#endif

#if 0
#define EMIO_GPIO_OFFSET                    54
#define EMIO_PIN_NUM(x)                     (x+EMIO_GPIO_OFFSET)
#define I2C_PIN_SCL0                        EMIO_PIN_NUM(16)
#define I2C_PIN_SDA0                        EMIO_PIN_NUM(17)
#define I2C_PIN_SCL1                        EMIO_PIN_NUM(14)
#define I2C_PIN_SDA1                        EMIO_PIN_NUM(15)
#define I2C_PIN_SCL2                        EMIO_PIN_NUM(12)
#define I2C_PIN_SDA2                        EMIO_PIN_NUM(13)
#define I2C_PIN_SCL3                        EMIO_PIN_NUM(18)
#define I2C_PIN_SDA3                        EMIO_PIN_NUM(19)
#else
#define I2C_PIN_SCL0                        8
#define I2C_PIN_SDA0                        9
#define I2C_PIN_SCL1                        10
#define I2C_PIN_SDA1                        11

#endif


static I2CInfo s_arrI2CInfo[] = {
		{0, {9, 0, 1, 1}, {9, 1, 1, 1}},
		{1, {9, 2, 1, 1}, {9, 3, 1, 1}},
		{2, {9, 4, 1, 1}, {9, 5, 1, 1}},
		{3, {10, 3, 1, 1}, {10, 4, 1, 1}},
		{4, {10, 5, 1, 1}, {10, 6, 1, 1}},
		{5, {10, 7, 1, 1}, {0, 0, 1, 1}},
		{6, {0, 1, 1, 1}, {0, 2, 1, 1}},
		{7, {0, 3, 1, 1}, {0, 4, 1, 1}}
	};

static pthread_mutex_t s_mutexI2C;


static U32 GetRegDir(int gpio_grp)
{
	int i = 0;
	U32 reg_val = 0;
	
	switch(gpio_grp)
	{
		case 0:
		{
			reg_val |= (s_arrI2CInfo[5].stSDA.dir);
			reg_val |= (s_arrI2CInfo[6].stSCL.dir << 1);
			reg_val |= (s_arrI2CInfo[6].stSDA.dir << 2);
			reg_val |= (s_arrI2CInfo[7].stSCL.dir << 3);
			reg_val |= (s_arrI2CInfo[7].stSDA.dir << 4);
			break;
		}
		case 9:
		{
			reg_val |= (s_arrI2CInfo[0].stSCL.dir);
			reg_val |= (s_arrI2CInfo[0].stSDA.dir << 1);
			reg_val |= (s_arrI2CInfo[1].stSCL.dir << 2);
			reg_val |= (s_arrI2CInfo[1].stSDA.dir << 3);
			reg_val |= (s_arrI2CInfo[2].stSCL.dir << 4);
			reg_val |= (s_arrI2CInfo[2].stSDA.dir << 5);
			break;
		}
		case 10:
		{
			reg_val |= (s_arrI2CInfo[3].stSCL.dir << 3);
			reg_val |= (s_arrI2CInfo[3].stSDA.dir << 4);
			reg_val |= (s_arrI2CInfo[4].stSCL.dir << 5);
			reg_val |= (s_arrI2CInfo[4].stSDA.dir << 6);
			reg_val |= (s_arrI2CInfo[5].stSCL.dir << 7);
			break;
		}
		default:
		{
			break;
		}
	}

	return reg_val;
}


// 这里不准
static void I2CSW_DelayUs(uint32_t us)
{
	GPIO_Delay(100000);
}

/*******************************************************************************
 * description:
 *   Set SCL/SDA pin mode, for input, output high, output low
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *   scl_sda: is scl or sda. 1, scl; 0, sda
 *   gpio_dirn: GPIO_IN, set the pin scl/sda as input
 *              GPIO_OUT, set the pin scl/sda as output
 *              GPIO_HIGH, set the pin scl/sda output high
 *              GPIO_LOW, set the pin scl/sda output low
 *
 * return: 
 *   void
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static void I2CSW_SetPinMode(I2CSW_IDX_T i2c_idx, bool scl_sda, GPIODirectionType gpio_dirn)
//static void I2CSW_SetPinMode(I2CSW_IDX_T i2c_idx, bool scl_sda, GPIOSTATUS gpio_status)
{
    uint8_t pin = 0;
    uint32_t pinVal = 0;
	uint32_t pinValR = 0;
    bool pinIn = false;
	I2CInfo *pstI2CInfo = NULL;
	GpioMuxerPin *pstGpioMuxerPin = NULL;
	uint32_t reg_val = 0;
	uint32_t dir_val = 0;

    switch (gpio_dirn)
    {
        case GPIO_IN:
            pinIn = true;
            break;
        case GPIO_HIGH:
            pinIn = false;
            pinVal = 1;
            break;
        case GPIO_LOW:
            pinIn = false;
            pinVal = 0;
            break;
        default:
            return;
    }

	pstI2CInfo = &s_arrI2CInfo[i2c_idx];
	pstGpioMuxerPin = scl_sda ? (&pstI2CInfo->stSCL) : (&pstI2CInfo->stSDA);

	if(pinIn)
    {
		pstGpioMuxerPin->dir = 0;
		dir_val = GetRegDir(pstGpioMuxerPin->muxer_pin_grp);
		pinVal = wv_gpio_SetIn(pstGpioMuxerPin->muxer_pin_grp, pstGpioMuxerPin->muxer_num, dir_val);
    }
    else
    {
		//SCL
		pstGpioMuxerPin->dir = 1;
		pstGpioMuxerPin->val = pinVal;
		
		dir_val = GetRegDir(pstGpioMuxerPin->muxer_pin_grp);
		if(scl_sda)
		{
			wv_gpio_WriteSCL(pstGpioMuxerPin->muxer_pin_grp, pstGpioMuxerPin->muxer_num, pinVal, dir_val);
		}
		else
		{
			wv_gpio_WriteSDA(pstGpioMuxerPin->muxer_pin_grp, pstGpioMuxerPin->muxer_num, pinVal, dir_val);
		}
		//wv_gpio_Write(pstGpioMuxerPin->muxer_pin_grp, pstGpioMuxerPin->muxer_num, pinVal);
		
    }

}

/*******************************************************************************
 * description:
 *   I2C start
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *
 * return: 
 *   void
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static void I2CSW_Start(I2CSW_IDX_T i2c_idx)
{
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_HIGH);
    I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_HIGH);
    I2CSW_DelayUs(TIME_SETUP_START);
    I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_LOW);
    I2CSW_DelayUs(TIME_HOLD_START);
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_LOW);
    I2CSW_DelayUs(TIME_DEALY_START);
}

/*******************************************************************************
 * description:
 *   I2C stop
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *
 * return: 
 *   void
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static void I2CSW_Stop(I2CSW_IDX_T i2c_idx)
{
    I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_LOW);
    I2CSW_DelayUs(2);
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_HIGH);;
    I2CSW_DelayUs(TIME_SETUP_STOP);
    I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_HIGH);
}

/*******************************************************************************
 * description:
 *   I2C write one bit
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *   val: the bit val to write
 *
 * return: 
 *   void
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static void I2CSW_WriteBit(I2CSW_IDX_T i2c_idx, bool val)
{
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_LOW);
    if (val)
    {
        I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_HIGH);
    }
    else
    {
        I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_LOW);
    }
    I2CSW_DelayUs(TIME_SETUP_DOUT);
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_HIGH);;
    I2CSW_DelayUs(TIME_SCL_HIGH);
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_LOW);
    I2CSW_DelayUs(TIME_HOLD_DOUT);
}

/*******************************************************************************
 * description:
 *   I2C read one bit
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *   val: the bit val to read
 *
 * return: 
 *   void
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static void I2CSW_ReadBit(I2CSW_IDX_T i2c_idx, U32 *pu32Value)
{
	#if 0
    uint8_t pin_sda = 0;
    switch (i2c_idx)
    {
        case I2CSW_0:
            pin_sda = I2C_PIN_SDA0;
            break;

        case I2CSW_1:
            pin_sda = I2C_PIN_SDA1;
            break;

        default:
            break;
    }
	#endif

	U32 u32Dir = 0;
	I2CInfo *pstI2CInfo;
	GpioMuxerPin *pstGpioMuxerPin;

	pstI2CInfo = &s_arrI2CInfo[i2c_idx];
	pstGpioMuxerPin = &(pstI2CInfo->stSDA);
    
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_LOW);
    I2CSW_DelayUs(TIME_SETUP_DIN);
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_HIGH);;
    I2CSW_DelayUs(TIME_SCL_HIGH);
    //GPIO_GetGpioVal(pin_sda, pu32Value);
    //logic_GetGPIO(pin_sda, pu32Value, EMIO);
    pstGpioMuxerPin->dir = 0;
	u32Dir = GetRegDir(pstGpioMuxerPin->muxer_pin_grp);
    *pu32Value = wv_gpio_Read(pstGpioMuxerPin->muxer_pin_grp , pstGpioMuxerPin->muxer_num, u32Dir);
	
	GPIO_Delay(100000);
    I2CSW_DelayUs(TIME_HOLD_DIN);
    I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_LOW);
}

/*******************************************************************************
 * description:
 *   I2C write one byte
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *   val: the value to write
 *
 * return: 
 *   void
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static void I2CSW_WriteByte(I2CSW_IDX_T i2c_idx, uint8_t val)
{
    int i = 0;
    uint8_t tmp = 0;

    for (i=0; i<8; i++)
    {
        tmp = (val >> (7-i)) & 0x01;
        I2CSW_WriteBit(i2c_idx, tmp);
    }

    I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_IN);
}

/*******************************************************************************
 * description:
 *   I2C read one byte
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *
 * return: 
 *   the byte value read from i2c
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static uint8_t I2CSW_ReadByte(I2CSW_IDX_T i2c_idx)
{
    int i = 0;
    uint32_t read = 0;
    bool bit = 0;
    uint8_t data  = 0;

    I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_IN);

    for (i = 0; i < 8; i++)
    {
        I2CSW_ReadBit(i2c_idx, &read);
        bit = (bool)read;
        data <<= 1;
        data |= bit;
    }

    return data;
}

/*******************************************************************************
 * description:
 *   I2C read ack
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *
 * return: 
 *   true: recieve an ack
 *   false: recieve a nack
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static bool I2CSW_ReadAck(I2CSW_IDX_T i2c_idx)
{
    uint32_t read = 0;
    
    I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_IN);
    
    I2CSW_ReadBit(i2c_idx, &read);

    if (read)
        return false;
    else
        return true;
}

/*******************************************************************************
 * description:
 *   I2C write ack
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *   ack: true, write an ack; false, write a nack.
 *
 * return: 
 *   none
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
static void I2CSW_WriteAck(I2CSW_IDX_T i2c_idx, bool ack)
{
    if (ack)
        I2CSW_WriteBit(i2c_idx, 0);
    else
        I2CSW_WriteBit(i2c_idx, 1);
}

/*******************************************************************************
 * description:
 *   I2C init
 *            
 * parameters:
 *   i2c_idx: the index of the gpio i2c
 *
 * return: 
 *    0         : ok
 * 
 * history:
 *   lei.huang@20170629 created
*******************************************************************************/
int I2CSW_Init(I2CSW_IDX_T i2c_idx)
{
    pthread_mutex_init(&s_mutexI2C, NULL);

	I2CInfo stI2CInfo;
	GpioMuxerPin stGpioMuxerPin;
	unsigned int val = 0;
	unsigned int dir = 0;

	stI2CInfo = s_arrI2CInfo[i2c_idx];
	dir = GetRegDir(stI2CInfo.stSCL.muxer_pin_grp);

	wv_gpio_SetMuxer(stI2CInfo.stSDA.muxer_pin_grp, stI2CInfo.stSDA.muxer_num);
	wv_gpio_SetMuxer(stI2CInfo.stSCL.muxer_pin_grp, stI2CInfo.stSCL.muxer_num);
	//wv_gpio_SetDir(stI2CInfo.stSCL.muxer_pin_grp, stI2CInfo.stSCL.muxer_num, dir);
	I2CSW_SetPinMode(i2c_idx, SEL_SCL, GPIO_HIGH);
	I2CSW_SetPinMode(i2c_idx, SEL_SDA, GPIO_HIGH);

    return 0;
}

/*******************************************************************************
 * description:
 *   I2C write one register
 *            
 * parameters:
 *   i2c_idx    : the index of the gpio i2c
 *   slave_addr : the slave address of the device
 *   reg_addr   : the register address to be write
 *   data       : the byte data to be write
 *
 * return: 
 *    0         : ok
 *   -2         : no ack
 * 
 * history:
 *   lei.huang@20170629 created
*******************************************************************************/
int I2CSW_WriteReg(I2CSW_IDX_T i2c_idx, uint8_t slave_addr, uint8_t reg_addr, uint8_t data)
{
    int ret = 0;

    pthread_mutex_lock(&s_mutexI2C);
    
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|0);
    if (!I2CSW_ReadAck(i2c_idx))
    {
		printf("I2CSW_WriteByte1 error: reg_addr:0x%x\n", reg_addr);
        ret = -2;
        goto exit;
    }
    I2CSW_WriteByte(i2c_idx, reg_addr);
    if (!I2CSW_ReadAck(i2c_idx))
    {
		printf("I2CSW_WriteByte2 error: addr:0x%x\n", reg_addr);
        ret = -2;
        goto exit;
    }
    I2CSW_WriteByte(i2c_idx, data);
    if (!I2CSW_ReadAck(i2c_idx))
    {
		printf("I2CSW_WriteByte3 error: addr:0x%x\n", reg_addr);
        ret = -2;
        goto exit;
    }

exit:
    I2CSW_Stop(i2c_idx);
    pthread_mutex_unlock(&s_mutexI2C);
    return ret;
}

/*******************************************************************************
 * description:
 *   I2C write one register
 *            
 * parameters:
 *   i2c_idx    : the index of the gpio i2c
 *   slave_addr : the slave address of the device
 *   reg_addr   : the register address to be read
 *   p_read     : output param for a reading byte value
 *
 * return: 
 *    0         : ok
 *   -1         : input param error
 *   -2         : no ack
 * 
 * history:
 *   lei.huang@20170629 created
*******************************************************************************/
int I2CSW_ReadReg(I2CSW_IDX_T i2c_idx, uint8_t slave_addr, uint8_t reg_addr, uint8_t *p_read)
{
	int ret = 0;

    if (p_read == NULL)
    {
        return -1;
    }

    pthread_mutex_lock(&s_mutexI2C);
    
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|0);    // slave address + W bit
    if (!I2CSW_ReadAck(i2c_idx))
    {
		printf("I2CSW_WriteByte1 error: reg_addr:0x%x\n", reg_addr);
        ret = -2;
        goto exit;
    }
    I2CSW_WriteByte(i2c_idx, reg_addr);             // write reg address
    if (!I2CSW_ReadAck(i2c_idx))
    {
		printf("I2CSW_WriteByte2 error: reg_addr:0x%x\n", reg_addr);
        ret = -2;
        goto exit;
    }
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|1);    // slave address + R bit
    if (!I2CSW_ReadAck(i2c_idx))
    {
		printf("I2CSW_WriteByte3 error: reg_addr:0x%x\n", reg_addr);
        ret = -2;
        goto exit;
    }
    *p_read = I2CSW_ReadByte(i2c_idx);
    I2CSW_WriteAck(i2c_idx, false);
    
exit:
    I2CSW_Stop(i2c_idx);
    pthread_mutex_unlock(&s_mutexI2C);
    return ret;
}

/*******************************************************************************
 * description:
 *   I2C write many register from current address
 *            
 * parameters:
 *   i2c_idx    : the index of the gpio i2c
 *   slave_addr : the slave address of the device
 *   p_buf      : the buffer has data to be write
 *   size       : size of the buffer
 *
 * return: 
 *    0         : ok
 *   -1         : input param error
 *   -2         : no ack
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
int I2CSW_WriteSeq(I2CSW_IDX_T i2c_idx, uint8_t slave_addr,
                    uint8_t *p_buf, uint8_t size)
{
    int i = 0;
    int ret = 0;

    if (p_buf == NULL || size == 0)
    {
        return -1;
    }
    
    pthread_mutex_lock(&s_mutexI2C);
    
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|0);
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }
    
    for (i=0; i<size; i++)
    {
        I2CSW_WriteByte(i2c_idx, p_buf[i]);
        if (!I2CSW_ReadAck(i2c_idx))
        {
            ret = -2;
            goto exit;
        }
    }
    
    ret = 0;
    
exit:
    I2CSW_Stop(i2c_idx);
    pthread_mutex_unlock(&s_mutexI2C);
    return ret;
}

/*******************************************************************************
 * description:
 *   I2C write many register from the special address
 *            
 * parameters:
 *   i2c_idx    : the index of the gpio i2c
 *   slave_addr : the slave address of the device
 *   reg_addr   : the begin register address to write
 *   p_buf      : the buffer has data to be write
 *   size       : size of the buffer
 *
 * return: 
 *    0         : ok
 *   -1         : input param error
 *   -2         : no ack
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
int I2CSW_WriteBuf(I2CSW_IDX_T i2c_idx, uint8_t slave_addr, uint8_t reg_addr, 
                   uint8_t *p_buf, uint8_t size)
{
    int i = 0;
    int ret = 0;

    if (p_buf == NULL || size == 0)
    {
        return -1;
    }
    
    pthread_mutex_lock(&s_mutexI2C);
    
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|0);
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }

    I2CSW_WriteByte(i2c_idx, reg_addr);
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }

    
    for (i=0; i<size; i++)
    {
        I2CSW_WriteByte(i2c_idx, p_buf[i]);
        if (!I2CSW_ReadAck(i2c_idx))
        {
            ret = -2;
            goto exit;
        }

    }
    
    I2CSW_Stop(i2c_idx);
    ret = 0;

exit:
    pthread_mutex_unlock(&s_mutexI2C);
    return ret;
}


/*******************************************************************************
 * description:
 *   I2C read many register from the current address
 *            
 * parameters:
 *   i2c_idx    : the index of the gpio i2c
 *   slave_addr : the slave address of the device
 *   p_buf      : the buffer saved the readout data
 *   size       : size of the buffer
 *
 * return: 
 *    0         : ok
 *   -1         : input param error
 *   -2         : no ack
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
int I2CSW_ReadSeq(I2CSW_IDX_T i2c_idx, uint8_t slave_addr,
                  uint8_t *p_buf, uint8_t size)
{
    int i = 0;
    int ret = -2;

    if (p_buf == NULL || size == 0)
    {
        return -1;
    }

    pthread_mutex_lock(&s_mutexI2C);
    
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|1);    // slave addr + R bit
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }

    for (i=0; i<size; i++)
    {
        p_buf[i] = I2CSW_ReadByte(i2c_idx);

        if (i < size-1)
        {
            I2CSW_WriteAck(i2c_idx, true);
        }
        else
        {
            //no ack the ninth phase
            I2CSW_WriteAck(i2c_idx, false);
        }
    }
  
    ret = 0;

exit:
    I2CSW_Stop(i2c_idx);
    pthread_mutex_unlock(&s_mutexI2C);
    return ret;
}

/*******************************************************************************
 * description:
 *   I2C read many register from the special address
 *            
 * parameters:
 *   i2c_idx    : the index of the gpio i2c
 *   slave_addr : the slave address of the device
 *   reg_addr   : the begin register address to read
 *   p_buf      : the buffer saved the readout data
 *   size       : size of the buffer
 *
 * return: 
 *    0         : ok
 *   -1         : input param error
 *   -2         : no ack
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
int I2CSW_ReadBuf(I2CSW_IDX_T i2c_idx, uint8_t slave_addr, uint8_t reg_addr, 
                  uint8_t *p_buf, uint8_t size)
{
    int i = 0;
    int ret = 0;

    if (p_buf == NULL || size == 0)
    {
        return -1;
    }

    pthread_mutex_lock(&s_mutexI2C);
    
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|0);    // slave addr + W bit
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }
    I2CSW_WriteByte(i2c_idx, reg_addr);             // write reg address
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|1);    // slave addr + R bit
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }

    for (i=0; i<size; i++)
    {
        p_buf[i] = I2CSW_ReadByte(i2c_idx);

        if (i < size-1)
        {
            I2CSW_WriteAck(i2c_idx, true);
        }
        else
        {
            //no ack the ninth phase
            I2CSW_WriteAck(i2c_idx, false);
        }
    }

exit:
    I2CSW_Stop(i2c_idx);
    pthread_mutex_unlock(&s_mutexI2C);
    
    return ret;
}



/*******************************************************************************
 * description:
 *   I2C read one register from the special address. 
 *   It's a non-standard i2c read.
 *            
 * parameters:
 *   i2c_idx    : the index of the gpio i2c
 *   slave_addr : the slave address of the device
 *   reg_addr   : the begin register address to read
 *   p_buf      : the buffer saved the readout data
 *   size       : size of the buffer
 *
 * return: 
 *    0         : ok
 *   -1         : input param error
 *   -2         : no ack
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
int I2CSW_ReadRegNonStd(I2CSW_IDX_T i2c_idx, uint8_t slave_addr, 
                         uint8_t reg_addr, uint8_t *p_read)
{
	int ret = 0;

    if (p_read == NULL)
    {
        return -1;
    }
    
    pthread_mutex_lock(&s_mutexI2C);
    
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|1);
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }
    I2CSW_WriteByte(i2c_idx, reg_addr);
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }
    *p_read = I2CSW_ReadByte(i2c_idx);
    I2CSW_WriteAck(i2c_idx, false);
    ret = 0;
    
exit:
    I2CSW_Stop(i2c_idx);
    pthread_mutex_unlock(&s_mutexI2C);
    return ret;
}

/*******************************************************************************
 * description:
 *   I2C read many register from the special address. 
 *   It's a non-standard i2c read.
 *            
 * parameters:
 *   i2c_idx    : the index of the gpio i2c
 *   slave_addr : the slave address of the device
 *   reg_addr   : the begin register address to read
 *   p_read     : output param to save the readout data
 *
 * return: 
 *   none
 * 
 * history:
 *   lei.huang@20170630 created
*******************************************************************************/
int I2CSW_ReadBufNonStd(I2CSW_IDX_T i2c_idx, uint8_t slave_addr, uint8_t reg_addr, 
                        uint8_t *p_buf, uint8_t size)
{
    int i;
    int ret = 0;

    if (p_buf == NULL || size == 0)
    {
        return -1;
    }

    pthread_mutex_lock(&s_mutexI2C);
    
    I2CSW_Start(i2c_idx);
    I2CSW_WriteByte(i2c_idx, (slave_addr<<1)|1);
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }
    I2CSW_WriteByte(i2c_idx, reg_addr);
    if (!I2CSW_ReadAck(i2c_idx))
    {
        ret = -2;
        goto exit;
    }

    for (i=0; i<size; i++)
    {
        p_buf[i] = I2CSW_ReadByte(i2c_idx);

        if (i < size-1)
        {
            I2CSW_WriteAck(i2c_idx, true);
        }
        else
        {
            //no ack the ninth phase
            I2CSW_WriteAck(i2c_idx, false);
        }
    }
  
    ret = 0;

exit:
    I2CSW_Stop(i2c_idx);
    pthread_mutex_unlock(&s_mutexI2C);
    return ret;
}

```

**i2c_gpio.h**

```
#ifndef __I2C_GPIO_H_
#define __I2C_GPIO_H_

#include <stdint.h>

typedef enum
{
    I2CSW_0     = 0,
    I2CSW_1     = 1,
}   I2CSW_IDX_T;




typedef struct _GpioMuxerPin
{
	uint8_t muxer_pin_grp;
	uint8_t muxer_num;
	uint8_t dir; //0-in , 1- out
	uint8_t val;
}GpioMuxerPin;

typedef struct _I2CInfo
{
	uint8_t index;
	GpioMuxerPin stSCL;
	GpioMuxerPin stSDA;
}I2CInfo;

int I2CSW_Init(I2CSW_IDX_T i2c_idx);
int I2CSW_WriteReg(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t raddr, uint8_t data);
int I2CSW_ReadReg(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t raddr, uint8_t *p_read);
int I2CSW_WriteBuf(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t raddr, uint8_t *p_buf, uint8_t size);
int I2CSW_ReadBuf(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t raddr, uint8_t *p_buf, uint8_t size);
int I2CSW_WriteSeq(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t *p_buf, uint8_t size);
int I2CSW_ReadSeq(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t *p_buf, uint8_t size);
int I2CSW_ReadBuf(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t raddr, uint8_t *p_buf, uint8_t size);
int I2CSW_WriteBuf(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t raddr, uint8_t *p_buf, uint8_t size);
int I2CSW_ReadRegNonStd(I2CSW_IDX_T i2c_idx, uint8_t saddr,  uint8_t raddr, uint8_t *p_read);
int I2CSW_ReadBufNonStd(I2CSW_IDX_T i2c_idx, uint8_t saddr, uint8_t raddr, uint8_t *p_buf, uint8_t size);

#endif
```

**wv_gpio.h**

```
/*****************************************************************************
 * Copyright(c), HuiZhou WELLAV Technology Co.,Ltd.
 * All rights reserved.
 *
 * FileName    ：wv_gpio.h
 * Description ：海思芯片GPIO操作接口
 *
 * Version ：1.0.0
 * Author  ：jiaqian.lin
 * Date    ：2018-4-4
 * Record  : Create
 ****************************************************************************/
#ifndef __wv_gpio_H__
#define	__wv_gpio_H__


#define GPIO_MUXCTRL_BASE_ADD	0x120F0000	//管脚复用控制寄存器基地址
#define GPIO_DIR				0x400	//GPIO 方向控制寄存器

//GPIO偏移地址表(管脚复用)
#define OFFSET_GPIO(x, n)		OFFSET_GPIO##x##_##n
//GPIO0_0~7
#define OFFSET_GPIO0_0			0x1D4
#define OFFSET_GPIO0_1			0x1D8 
#define OFFSET_GPIO0_2			0x1DC 
#define OFFSET_GPIO0_3			0x1E0 
#define OFFSET_GPIO0_4			0x1E4 
#define OFFSET_GPIO0_5			0x1E8 
#define OFFSET_GPIO0_6			0x1EC
#define OFFSET_GPIO0_7			0x1F0 

//GPIO1_0~7
#define OFFSET_GPIO1_0			0x00C
#define OFFSET_GPIO1_1			0x0D0 
#define OFFSET_GPIO1_2			0x108 
#define OFFSET_GPIO1_3			0x194 
#define OFFSET_GPIO1_4			0x198 
#define OFFSET_GPIO1_5			0x19C 
#define OFFSET_GPIO1_6			0x15C  
#define OFFSET_GPIO1_7			0x160 

//GPIO2_0~7
#define OFFSET_GPIO2_0			0x0B0
#define OFFSET_GPIO2_1			0x0B4 
#define OFFSET_GPIO2_2			0x0B8 
#define OFFSET_GPIO2_3			0x0BC 
#define OFFSET_GPIO2_4			0x0C0 
#define OFFSET_GPIO2_5			0x0C4 
#define OFFSET_GPIO2_6			0x0C8 
#define OFFSET_GPIO2_7			0x0CC 

//GPIO3_0~7
#define OFFSET_GPIO3_0			0x12C
#define OFFSET_GPIO3_1			0x130 
#define OFFSET_GPIO3_2			0x134 
#define OFFSET_GPIO3_3			0x138 
#define OFFSET_GPIO3_4			0x13C 
#define OFFSET_GPIO3_5			0x140 
#define OFFSET_GPIO3_6			0x144 
#define OFFSET_GPIO3_7			0x148 

//GPIO4_0~7
#define OFFSET_GPIO4_0			0x174
#define OFFSET_GPIO4_1			0x178 
#define OFFSET_GPIO4_2			0x17C 
#define OFFSET_GPIO4_3			0x180 
#define OFFSET_GPIO4_4			0x184 
#define OFFSET_GPIO4_5			0x188 
#define OFFSET_GPIO4_6			0x18C 
#define OFFSET_GPIO4_7			0x190 

//GPIO5_0~7
#define OFFSET_GPIO5_0			0x10C
#define OFFSET_GPIO5_1			0x110 
#define OFFSET_GPIO5_2			0x114 
#define OFFSET_GPIO5_3			0x118 
#define OFFSET_GPIO5_4			0x11C 
#define OFFSET_GPIO5_5			0x120 
#define OFFSET_GPIO5_6			0x124 
#define OFFSET_GPIO5_7			0x128 

//GPIO6_0~7
#define OFFSET_GPIO6_0			0x010
#define OFFSET_GPIO6_1			0x014 
#define OFFSET_GPIO6_2			0x018 
#define OFFSET_GPIO6_3			0x01C 
#define OFFSET_GPIO6_4			0x020 
#define OFFSET_GPIO6_5			0x024 
#define OFFSET_GPIO6_6			0x028 
#define OFFSET_GPIO6_7			0x02C

//GPIO7_0~7
#define OFFSET_GPIO7_0			0x030
#define OFFSET_GPIO7_1			0x034 
#define OFFSET_GPIO7_2			0x038 
#define OFFSET_GPIO7_3			0x03C 
#define OFFSET_GPIO7_4			0x040 
#define OFFSET_GPIO7_5			0x044 
#define OFFSET_GPIO7_6			0x048 
#define OFFSET_GPIO7_7			0x04C

//GPIO8_0~7
#define OFFSET_GPIO8_0			0x050
#define OFFSET_GPIO8_1			0x054 
#define OFFSET_GPIO8_2			0x058 
#define OFFSET_GPIO8_3			0x05C 
#define OFFSET_GPIO8_4			0x060 
#define OFFSET_GPIO8_5			0x064 
#define OFFSET_GPIO8_6			0x068 
#define OFFSET_GPIO8_7			0x06C 

//GPIO9_0~7
#define OFFSET_GPIO9_0			0x158
#define OFFSET_GPIO9_1			0x15C 
#define OFFSET_GPIO9_2			0x160 
#define OFFSET_GPIO9_3			0x164
#define OFFSET_GPIO9_4			0x168 
#define OFFSET_GPIO9_5			0x16C
#define OFFSET_GPIO9_6			0x170
#define OFFSET_GPIO9_7			0x174 

//GPIO10_0~7
#define OFFSET_GPIO10_0			0x178
#define OFFSET_GPIO10_1			0x17C 
#define OFFSET_GPIO10_2			0x180 
#define OFFSET_GPIO10_3			0x184 
#define OFFSET_GPIO10_4			0x188 
#define OFFSET_GPIO10_5			0x18C 
#define OFFSET_GPIO10_6			0x190 
#define OFFSET_GPIO10_7			0x194 

//GPIO11_0~7
#define OFFSET_GPIO11_0			0x0E8
#define OFFSET_GPIO11_1			0x0EC 
#define OFFSET_GPIO11_2			0x0F0 
#define OFFSET_GPIO11_3			0x0F4 
#define OFFSET_GPIO11_4			0x0F8 
#define OFFSET_GPIO11_5			0x0FC 
#define OFFSET_GPIO11_6			0x100 
#define OFFSET_GPIO11_7			0x104 

//GPIO12_0~7
#define OFFSET_GPIO12_0			0x1AC
#define OFFSET_GPIO12_1			0x1B0 
#define OFFSET_GPIO12_2			0x1B4 
#define OFFSET_GPIO12_3			0x1B8 
#define OFFSET_GPIO12_4			0x1BC 
#define OFFSET_GPIO12_5			0x1C0 
#define OFFSET_GPIO12_6			0x1C4 
#define OFFSET_GPIO12_7			0x1C8

//GPIO13_0~7
#define OFFSET_GPIO13_0			0x1CC
#define OFFSET_GPIO13_1			0x1D0 
#define OFFSET_GPIO13_2			0x1D4 
#define OFFSET_GPIO13_3			0x1D8 
#define OFFSET_GPIO13_4			0x1DC 
#define OFFSET_GPIO13_5			0x1E0 
#define OFFSET_GPIO13_6			0x1E4 
#define OFFSET_GPIO13_7			0x1E8 


//GPIO14_0~7
#define OFFSET_GPIO14_0			0x14C
#define OFFSET_GPIO14_1			0x150 
#define OFFSET_GPIO14_2			0x154 
#define OFFSET_GPIO14_3			0x158 
#define OFFSET_GPIO14_4			0x164 
#define OFFSET_GPIO14_5			0x168 
#define OFFSET_GPIO14_6			0x16C 
#define OFFSET_GPIO14_7			0x170 

//GPIO15_0~2
#define OFFSET_GPIO15_0			0x1A0
#define OFFSET_GPIO15_1			0x1A4 
#define OFFSET_GPIO15_2			0x1A8 



#define BASE_GPIO(x)		 BASE_GPIO##x
//16组 GPIO 寄存器对应的基地址
#define BASE_GPIO0			0x12150000
#define BASE_GPIO1			0x12160000
#define BASE_GPIO2			0x12170000
#define BASE_GPIO3			0x12180000
#define BASE_GPIO4			0x12190000
#define BASE_GPIO5			0x121A0000
#define BASE_GPIO6			0x121B0000
#define BASE_GPIO7			0x121C0000
#define BASE_GPIO8			0x121D0000
#define BASE_GPIO9			0x121E0000
#define BASE_GPIO10			0x121F0000
#define BASE_GPIO11			0x12200000
#define BASE_GPIO12			0x12210000
#define BASE_GPIO13			0x12220000
#define BASE_GPIO14			0x12230000
#define BASE_GPIO15			0x12240000


#define BASE_SPI0			0x200c0000
#define BASE_SPI1			0x200e0000

#define OFFSET_SPICR0		0x000
#define OFFSET_SPICR1		0x004

#define OFFSET_SPICPSR		0x010
#define OFFSET_SPIIMSC 		0x014

#define OFFSET_SPITXFIFOCR 	0x028 
#define OFFSET_SPIRXFIFOCR 	0x02C
#define OFFSET_SPIDMACR 	0x024

typedef enum {
	GPIO0,
	GPIO1,
	GPIO2,
	GPIO3,
	GPIO4,
	GPIO5,
	GPIO6,
	GPIO7,
	GPIO8,
	GPIO9,
	GPIO10,
	GPIO11,
	GPIO12,
	GPIO13,
	GPIO14,
	GPIO15,

}GPIO_N;

typedef enum{
    GPIO_OUT            =           0X0,
    GPIO_IN             =           0X1,    
    GPIO_HIGH           =           0x2,
    GPIO_LOW            =           0x3
}GPIODirectionType;



const U32 OFFSET_GPIO_ARRAY[16][8];
const U32 BASE_GPIO_ARRAY[16];

void wv_gpio_SPI_INIT(void);
void wv_gpio_Write(GPIO_N eGPIOn, U8 u8Num, U32 u32Val);
U32 wv_gpio_Read(GPIO_N eGPIOn, U8 u8Num, U32 u32Dir);
void SPIBUS_Init2(void);
void I2C_Init2(void);


#endif
```




**gpio.c**
```
/*****************************************************************************
 * Copyright(c), HuiZhou WELLAV Technology Co.,Ltd.
 * All rights reserved.
 *
 * FileName    ：wv_gpio.c
 * Description ：海思芯片GPIO操作接口,使用规则参考海思文档
 * 
 * Version ：1.0.0
 * Author  ：jiaqian.lin
 * Date    ：2018-4-4
 * Record  : Create
 ****************************************************************************/
#include <time.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/fb.h>
#include <sys/mman.h>
#include <memory.h>
#include <sys/ioctl.h>

#include "appGlobal.h"
#include "wv_gpio.h"
#include "mpi_sys.h"


const U32 OFFSET_GPIO_ARRAY[16][8] = {
	{OFFSET_GPIO(0, 0), OFFSET_GPIO(0, 1), OFFSET_GPIO(0, 2), OFFSET_GPIO(0, 3), OFFSET_GPIO(0, 4), OFFSET_GPIO(0, 5), OFFSET_GPIO(0, 6), OFFSET_GPIO(0, 7)},
	{OFFSET_GPIO(1, 0), OFFSET_GPIO(1, 1), OFFSET_GPIO(1, 2), OFFSET_GPIO(1, 3), OFFSET_GPIO(1, 4), OFFSET_GPIO(1, 5), OFFSET_GPIO(1, 6), OFFSET_GPIO(1, 7)},
	{OFFSET_GPIO(2, 0), OFFSET_GPIO(2, 1), OFFSET_GPIO(2, 2), OFFSET_GPIO(2, 3), OFFSET_GPIO(2, 4), OFFSET_GPIO(2, 5), OFFSET_GPIO(2, 6), OFFSET_GPIO(2, 7)},
	{OFFSET_GPIO(3, 0), OFFSET_GPIO(3, 1), OFFSET_GPIO(3, 2), OFFSET_GPIO(3, 3), OFFSET_GPIO(3, 4), OFFSET_GPIO(3, 5), OFFSET_GPIO(3, 6), OFFSET_GPIO(3, 7)},
	{OFFSET_GPIO(4, 0), OFFSET_GPIO(4, 1), OFFSET_GPIO(4, 2), OFFSET_GPIO(4, 3), OFFSET_GPIO(4, 4), OFFSET_GPIO(4, 5), OFFSET_GPIO(4, 6), OFFSET_GPIO(4, 7)},
	{OFFSET_GPIO(5, 0), OFFSET_GPIO(5, 1), OFFSET_GPIO(5, 2), OFFSET_GPIO(5, 3), OFFSET_GPIO(5, 4), OFFSET_GPIO(5, 5), OFFSET_GPIO(5, 6), OFFSET_GPIO(5, 7)},
	{OFFSET_GPIO(6, 0), OFFSET_GPIO(6, 1), OFFSET_GPIO(6, 2), OFFSET_GPIO(6, 3), OFFSET_GPIO(6, 4), OFFSET_GPIO(6, 5), OFFSET_GPIO(6, 6), OFFSET_GPIO(6, 7)},
	{OFFSET_GPIO(7, 0), OFFSET_GPIO(7, 1), OFFSET_GPIO(7, 2), OFFSET_GPIO(7, 3), OFFSET_GPIO(7, 4), OFFSET_GPIO(7, 5), OFFSET_GPIO(7, 6), OFFSET_GPIO(7, 7)},
	{OFFSET_GPIO(8, 0), OFFSET_GPIO(8, 1), OFFSET_GPIO(8, 2), OFFSET_GPIO(8, 3), OFFSET_GPIO(8, 4), OFFSET_GPIO(8, 5), OFFSET_GPIO(8, 6), OFFSET_GPIO(8, 7)},
	{OFFSET_GPIO(9, 0), OFFSET_GPIO(9, 1), OFFSET_GPIO(9, 2), OFFSET_GPIO(9, 3), OFFSET_GPIO(9, 4), OFFSET_GPIO(9, 5), OFFSET_GPIO(9, 6), OFFSET_GPIO(9, 7)},
	{OFFSET_GPIO(10, 0), OFFSET_GPIO(10, 1), OFFSET_GPIO(10, 2), OFFSET_GPIO(10, 3), OFFSET_GPIO(10, 4), OFFSET_GPIO(10, 5), OFFSET_GPIO(10, 6), OFFSET_GPIO(10, 7)},
	{OFFSET_GPIO(11, 0), OFFSET_GPIO(11, 1), OFFSET_GPIO(11, 2), OFFSET_GPIO(11, 3), OFFSET_GPIO(11, 4), OFFSET_GPIO(11, 5), OFFSET_GPIO(11, 6), OFFSET_GPIO(11, 7)},
	{OFFSET_GPIO(12, 0), OFFSET_GPIO(12, 1), OFFSET_GPIO(12, 2), OFFSET_GPIO(12, 3), OFFSET_GPIO(12, 4), OFFSET_GPIO(12, 5), OFFSET_GPIO(12, 6), OFFSET_GPIO(12, 7)},
	{OFFSET_GPIO(13, 0), OFFSET_GPIO(13, 1), OFFSET_GPIO(13, 2), OFFSET_GPIO(13, 3), OFFSET_GPIO(13, 4), OFFSET_GPIO(13, 5), OFFSET_GPIO(13, 6), OFFSET_GPIO(13, 7)},
	{OFFSET_GPIO(14, 0), OFFSET_GPIO(14, 1), OFFSET_GPIO(14, 2), OFFSET_GPIO(14, 3), OFFSET_GPIO(14, 4), OFFSET_GPIO(14, 5), OFFSET_GPIO(14, 6), OFFSET_GPIO(14, 7)},
	{OFFSET_GPIO(15, 0), OFFSET_GPIO(15, 1), OFFSET_GPIO(15, 2)},
};

const U32 BASE_GPIO_ARRAY[16] = {
	BASE_GPIO(0), BASE_GPIO(1), BASE_GPIO(2), BASE_GPIO(3), BASE_GPIO(4), BASE_GPIO(5), BASE_GPIO(6),
	BASE_GPIO(7), BASE_GPIO(8), BASE_GPIO(9), BASE_GPIO(10), BASE_GPIO(11), BASE_GPIO(12), BASE_GPIO(13),
	BASE_GPIO(14), BASE_GPIO(15),
};

void GPIO_Delay(int i)
{
	while(--i > 0)
	{
		asm("nop");
	}
}


//说明：
//GPIOn 对应的寄存器地址为：GPIOn 基地址+该寄存器偏移地址
//n 的取值范围：[0, 15]
//todo:封装GPIO操作接口        中间层+海思层

U32 Offset_GPIO(GPIO_N eGPIOn, U8 u8Num)
{
	return OFFSET_GPIO_ARRAY[eGPIOn][u8Num];
}

U32 Base_GPIO(GPIO_N eGPIOn)
{
	return BASE_GPIO_ARRAY[eGPIOn];
}

void wv_gpio_SetMuxer(GPIO_N eGPIOn, U8 u8Num)
{
	U32 u32MuxCtrlReg = 0;
	U32 u32DirReg = 0;
	U32 u32DataReg = 0;
	U32 u32OldDir = 0;
	U32 u32OldVal = 0;
	
	u32MuxCtrlReg = GPIO_MUXCTRL_BASE_ADD + Offset_GPIO(eGPIOn, u8Num);
	u32DirReg = Base_GPIO(eGPIOn) + GPIO_DIR;
	u32DataReg = Base_GPIO(eGPIOn) + (U32)(0x1<<(u8Num+2));

	HI_MPI_SYS_SetReg(u32MuxCtrlReg, 0x0);
}

void wv_gpio_SetDir(GPIO_N eGPIOn, U8 u8Num, U32 u32Dir)
{
	U32 u32MuxCtrlReg = 0;
	U32 u32DirReg = 0;
	U32 u32DataReg = 0;
	U32 u32OldDir = 0;
	U32 u32OldVal = 0;
	
	u32DirReg = Base_GPIO(eGPIOn) + GPIO_DIR;
	HI_MPI_SYS_SetReg(u32DirReg, u32Dir);
		
	#if 0
	switch(eGPIOn)
	{
		case 0:
		{
			HI_MPI_SYS_SetReg(u32DirReg, 0x1f); //配置操作管脚为输出模式
			break;
		}
		case 9:
		{
			HI_MPI_SYS_SetReg(u32DirReg, 0x3f); //配置操作管脚为输出模式
			break;
		}
		case 10:
		{
			HI_MPI_SYS_SetReg(u32DirReg, 0xf8); //配置操作管脚为输出模式
			break;
		}
		default:
		{
			break;
		}
	}
	#endif
}

void wv_gpio_WriteSCL(GPIO_N eGPIOn, U8 u8Num, U32 u32Val, U32 u32Dir)
{
	U32 u32MuxCtrlReg = 0;
	U32 u32DirReg = 0;
	U32 u32DataReg = 0;
	U32 u32OldDir = 0;
	U32 u32OldVal = 0;
	
	
	u32MuxCtrlReg = GPIO_MUXCTRL_BASE_ADD + Offset_GPIO(eGPIOn, u8Num);
	u32DirReg = Base_GPIO(eGPIOn) + GPIO_DIR;
	u32DataReg = Base_GPIO(eGPIOn) + (U32)(0x1<<(u8Num+2));

	//HI_MPI_SYS_SetReg(u32MuxCtrlReg, 0x0);

	HI_MPI_SYS_SetReg(u32DirReg, u32Dir);
	if(1 == u32Val)
	{
		HI_MPI_SYS_SetReg(u32DataReg, (0x1<<u8Num));
	}
	else
	{
		HI_MPI_SYS_SetReg(u32DataReg, 0);
	}
	
	//printf("u32DirReg=0x%x\n", u32DirReg);
	//printf("u32Dir=0x%x\n", u32Dir);
	//printf("u32Val=0x%x\n", u32Val);
}



void wv_gpio_WriteSDA(GPIO_N eGPIOn, U8 u8Num, U32 u32Val, U32 u32Dir)
{
	U32 u32MuxCtrlReg = 0;
	U32 u32DirReg = 0;
	U32 u32DataReg = 0;
	U32 u32OldDir = 0;
	U32 u32OldVal = 0;
	
	
	u32MuxCtrlReg = GPIO_MUXCTRL_BASE_ADD + Offset_GPIO(eGPIOn, u8Num);
	u32DirReg = Base_GPIO(eGPIOn) + GPIO_DIR;
	u32DataReg = Base_GPIO(eGPIOn) + (U32)(0x1<<(u8Num+2));

	//HI_MPI_SYS_SetReg(u32MuxCtrlReg, 0x0);

	HI_MPI_SYS_SetReg(u32DirReg, u32Dir);
	
	if(1 == u32Val)
	{
		HI_MPI_SYS_SetReg(u32DataReg, (0x1<<u8Num));
	}
	else
	{
		HI_MPI_SYS_SetReg(u32DataReg, 0);
	}
	
	//printf("u32Dir=0x%x\n", u32Dir);
	//printf("u32Val=0x%x\n", u32Val);

}




U32 wv_gpio_SetIn(GPIO_N eGPIOn, U8 u8Num, U32 u32Dir)
{
	U32 u32MuxCtrlReg = 0;
	U32 u32DirReg = 0;
	U32 u32DataReg = 0;
	U32 u32Val = 0;
	U32 u32OldDir = 0;

	
	u32MuxCtrlReg = GPIO_MUXCTRL_BASE_ADD + Offset_GPIO(eGPIOn, u8Num);
	u32DirReg = Base_GPIO(eGPIOn) + GPIO_DIR;
	u32DataReg = Base_GPIO(eGPIOn) + (U32)(0x1<<(u8Num+2));

	HI_MPI_SYS_SetReg(u32MuxCtrlReg, 0x0);
	
	HI_MPI_SYS_SetReg(u32DirReg, u32Dir);
	
	u32Val = (u32Val>>u8Num)&0x1;
	(0x1 == u32Val) ? (u32Val = 1):(u32Val = 0);
	

	return u32Val;
}


U32 wv_gpio_Read(GPIO_N eGPIOn, U8 u8Num, U32 u32Dir)
{
	U32 u32MuxCtrlReg = 0;
	U32 u32DirReg = 0;
	U32 u32DataReg = 0;
	U32 u32Val = 0;
	U32 u32OldDir = 0;
	
	u32MuxCtrlReg = GPIO_MUXCTRL_BASE_ADD + Offset_GPIO(eGPIOn, u8Num);
	u32DirReg = Base_GPIO(eGPIOn) + GPIO_DIR;
	u32DataReg = Base_GPIO(eGPIOn) + (U32)(0x1<<(u8Num+2));

	HI_MPI_SYS_SetReg(u32DirReg, u32Dir);
	
	GPIO_Delay(100000);
	HI_MPI_SYS_GetReg(u32DataReg, &u32Val);
	
	
	u32Val = (u32Val>>u8Num)&0x1;
	(0x1 == u32Val) ? (u32Val = 1):(u32Val = 0);
	

	return u32Val;
}

```